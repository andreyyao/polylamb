use crate::system_f::{ast, lex, parse::utils};
use crate::system_f::ast::Span;
use ast::{Prog, Decl, Expr, RawExpr, Type, RawType};


grammar<'a>;

// Using tokens from Logos
extern {
    type Location = usize;
    type Error = lex::LexicalError;
    enum lex::Token<'a> {
        "."         => lex::Token::Dot,
        ","         => lex::Token::Comma,
        ":"         => lex::Token::Colon,
        "="         => lex::Token::Equal,
        "("         => lex::Token::LParen,
        ")"         => lex::Token::RParen,
        "["         => lex::Token::LBrack,
        "]"         => lex::Token::RBrack,
        "_"         => lex::Token::Underscore,
        "->"        => lex::Token::Arrow,
        "*"         => lex::Token::Mul,
        "infix6"    => lex::Token::Infix6(<&'a str>),
        "infix4"    => lex::Token::Infix4(<&'a str>),
        "infix3"    => lex::Token::Infix3(<&'a str>),
        "eid"       => lex::Token::ExpId(<&'a str>),
        "tid"       => lex::Token::TypId(<&'a str>),
        "intLit"    => lex::Token::IntLit(<i64>),
        "boolLit"   => lex::Token::BoolLit(<bool>),
        "unitLit"   => lex::Token::UnitLit,
        "if"        => lex::Token::If,
        "then"      => lex::Token::Then,
        "else"      => lex::Token::Else,
        "let"       => lex::Token::Let,
        "in"        => lex::Token::In,
        "end"       => lex::Token::End,
        "any"       => lex::Token::Any,
        "lambda"    => lex::Token::Lambda,
        "forall"    => lex::Token::Forall,
        "Int"       => lex::Token::TInt,
        "Bool"      => lex::Token::TBool,
        "Unit"      => lex::Token::TUnit
    }
}

pub Prog: Prog = {
    <ds: Decl+> => {
        let mut m = Prog::new();
        for d in ds {
            m.declarations.insert(d.id.to_string(), d);
        }
        m
    }
}

pub Decl: ast::Decl = {
    "let" <v: "eid"> ":" <t: TypExpr> "=" <e: ValExpr> =>
        Decl{ id: v.to_string(), sig: t, body: e }
}

//////////////////////////////////////////////////
///////////////////// EXPR ///////////////////////
//////////////////////////////////////////////////

pub ValExpr: Expr = {
    <e: ValExpr2> => e,
    <e: ValExprIf> => e,
    <e: ValExprLet> => e,
    // <e: ValExprMatch> => e
}

ValExprIf: Expr = {
    <l: @L> "if" <e1: ValExpr> "then" <e2: ValExpr> "else" <e3: ValExpr> <r: @R> =>
        Expr {
            expr: RawExpr::If{
                cond: Box::new(e1),
                t: Box::new(e2),
                f: Box::new(e3)
            },
	    span: Some(Span::new(l, r))
        }
}

ValExprLet: Expr = {
    <l: @L> "let" <pat: Pattern> "=" <e1: ValExpr> "in" <e2: ValExpr> <r: @R> =>
        Expr {
	    expr: RawExpr::Let{
	        pat, exp: Box::new(e1), body: Box::new(e2)
	    },
	    span: Some(Span::new(l, r))
	}
}

// ValExprMatch: Expr = {
//   <l: @L> "match" <e: ValExpr> "with" <c: Pattern> "=>" <b: ValExpr> "end" <r: @R> =>
//        Expr {
//	    expr: RawExpr::Match{
//	        exp: Box::new(e), clause: (c, Box::new(b))
//            },
//	    span: Some(Span::new(l, r))
//	}
// }


///////////// Precedence babyyyy /////////////

// Lambda and any. Expression body extends as far as possible
ValExpr2: Expr = {
    <l: @L> "lambda" <a: Sep<Annot, ",">> "." <e: ValExpr> <r: @R> =>
        Expr {
	    expr: RawExpr::Lambda{ args: a, body: Box::new(e) },
	    span: Some(Span::new(l, r))
	},
    <l: @L> "any" <a: TypVar> "." <e: ValExpr> <r: @R> =>
        Expr {
	    expr: RawExpr::Any{ poly: a, body: Box::new(e) },
	    span: Some(Span::new(l, r))
	},
    <e: ValExpr3> => e
}

// Binops with && ||, precedence 3, left assoc
ValExpr3: Expr = {
    <l: @L> <e1: ValExpr3> <o: "infix3"> <e2:ValExpr4> <r: @R> =>
        Expr {
            expr: utils::make_binop(e1, o, e2),
	    span: Some(Span::new(l, r))
	},
    <e: ValExpr4> => e
}

// Binops with < > == !=, precedence 4, left assoc
ValExpr4: Expr = {
    <l: @L> <e1: ValExpr4> <o: "infix4"> <e2: ValExpr6> <r: @R> =>
        Expr {
            expr: utils::make_binop(e1, o, e2),
	    span: Some(Span::new(l, r))
	},
    <e: ValExpr6> => e
}

// Binops with + -, precedence 6, left assoc
ValExpr6: Expr = {
    <l: @L> <e1: ValExpr6> <o: "infix6"> <e2: ValExpr7> <r: @R> =>
        Expr {
            expr: utils::make_binop(e1, o, e2),
	    span: Some(Span::new(l, r))
	},
    <e: ValExpr7> => e
}

// Binops with *, precedence 7, left assoc
ValExpr7: Expr = {
    <l: @L> <e1: ValExpr7> "*" <e2: ValExpr8> <r: @R> =>
        Expr {
            expr: utils::make_binop(e1, "*", e2),
	    span: Some(Span::new(l, r))
	},
    <e: ValExpr8> => e
}

// Application, precedence 8, left assoc
ValExpr8: Expr = {
    // Expression application
    <l: @L> <e1: ValExpr8> <e2: ValExprAtom> <r: @R> =>
        Expr {
            expr: RawExpr::EApp{ exp: Box::new(e1), arg: Box::new(e2) },
	    span: Some(Span::new(l, r))
	},
    // Type application
    <l: @L> <e: ValExpr8> "[" <t: TypExpr> "]" <r: @R> =>
        Expr {
            expr: RawExpr::TApp{ exp: Box::new(e), arg: t },
	    span: Some(Span::new(l, r))
	},
    <e: ValExprAtom> => e
}

// Atomic expressions have no ambiguities. Highest precedence
ValExprAtom: Expr = {
    <l: @L> <z: "intLit"> <r: @R> =>
        Expr {
	    expr: RawExpr::Con{ val: ast::Constant::Integer(z) },
	    span: Some(Span::new(l, r))
	},
    <l: @L> <b: "boolLit"> <r: @R> =>
        Expr {
	    expr: RawExpr::Con{ val: ast::Constant::Boolean(b) },
	    span: Some(Span::new(l, r))
	},
    <l: @L> "unitLit" <r: @R> =>
        Expr {
	    expr: RawExpr::Con{ val: ast::Constant::Null },
	    span: Some(Span::new(l, r))
	},
    <l: @L> <v: "eid"> <r: @R> =>
        Expr {
	    expr: RawExpr::Var{ id: v.to_string() },
	    span: Some(Span::new(l, r))
	},
    <l: @L> "(" <es: SepMulti<ValExpr, ",">> ")" <r: @R> =>
        Expr {
	    expr: RawExpr::Tuple{ entries: es },
	    span: Some(Span::new(l, r))
	},
    "(" <e: ValExpr> ")" => e,
}

//////////////////////////////////////////////////
///////////////////// TYPE ///////////////////////
//////////////////////////////////////////////////

pub TypExpr: Type = {
    <t: TypExprForall> => t
}

TypExprForall: Type = {
    <l: @L> "forall" <tv: "tid"> "." <te: TypExpr> <r: @R> =>
	Type { typ: RawType::Forall(tv.to_string(), Box::new(te)), span: Some(Span::new(l, r)) },
    <t: TypExprArrow> => t
}

TypExprArrow: Type = {
    <l: @L> <t1: TypExprProd> "->" <t2: TypExprArrow> <r: @R> =>
        Type { typ: RawType::Arrow(Box::new(t1), Box::new(t2)), span: Some(Span::new(l, r)) },
    <t: TypExprProd> => t
}

TypExprProd: Type = {
    <l: @L> <ts: SepMulti<TypExprAtom, "*">> <r: @R> =>
        Type { typ: RawType::Prod(ts), span: Some(Span::new(l, r)) },
    <t: TypExprAtom> => t
}

TypExprAtom: Type = {
    <l: @L> "Int" <r: @R> =>
        Type { typ: RawType::Int, span: Some(Span::new(l, r)) },
    <l: @L> "Bool" <r: @R> =>
        Type { typ: RawType::Bool, span: Some(Span::new(l, r)) },
    <l: @L> "Unit" <r: @R> =>
        Type { typ: RawType::Unit, span: Some(Span::new(l, r)) },
    <l: @L> <v: TypVar> <r: @R> =>
        Type { typ: RawType::TVar(v), span: Some(Span::new(l, r)) },
    "(" <t: TypExpr> ")" => t
}

TypVar: String = {
    <t: "tid"> => t.to_owned()
}


///////////// HELPERS //////////////
// One or more T's separated by S's
Sep<T, S>: Vec<T> = {
    <sep: SepMulti<T, S>> => sep,
    <atom: T> => vec![atom]
}

// Two or more T's separated by S's
SepMulti<T, S>: Vec<T> = {
    <l: (<T> S)+> <r: T> =>
        { let mut l = l; l.push(r); l }
}


// Pattern
Pattern: ast::Pattern = {
    "(" <multi: SepMulti<Pattern, ",">> ")" =>
        ast::Pattern::Tuple(multi),
    <a: Annot> => ast::Pattern::Annot(a.0, a.1),
    "_" => ast::Pattern::Wildcard
}


// Type annotated identifier
Annot: (String, ast::Type) = {
    <v1: "eid"> ":" <t: TypExpr> => (v1.to_string(), t)
}

//////////// END HELPERS /////////////