use crate::{ast, lex, parse::utils};

grammar<'a>;

//Using tokens from Logos
extern {
  type Location = usize;
  type Error = lex::LexicalError;
  enum lex::Token<'a> {
    ":"     => lex::Token::Colon,
    ","	    => lex::Token::Comma,
    "->"    => lex::Token::Arrow,
    "=>"    => lex::Token::TwoArrow,
    "("	    => lex::Token::LParen,
    ")"	    => lex::Token::RParen,
    "="	    => lex::Token::Equal,
    "*"	    => lex::Token::Mul,
    "infix3"=> lex::Token::Infix3(<&'a str>),
    "infix4"=> lex::Token::Infix4(<&'a str>),
    "infix6"=> lex::Token::Infix6(<&'a str>),
    "ident" => lex::Token::Ident(<&'a str>),
    "intLit"   => lex::Token::IntLit(<i64>),
    "boolLit"  => lex::Token::BoolLit(<bool>),
    "if"    => lex::Token::If,
    "then"  => lex::Token::Then,
    "else"  => lex::Token::Else,
    "val"   => lex::Token::Val,
    "rec"   => lex::Token::Rec,
    "fn"    => lex::Token::Fn,
    "error" => lex::Token::Error
  }
}

pub Expr: ast::Expr = {
    <e: Expr2> => e,
    <e: ExprIf> => e
}

//////// Precedence babyyyy ////////

// Lambda expressions
Expr2: ast::Expr = {
    "fn" <p: Pattern> ":" <t: "ident"> "=>" <e: Expr3> =>
    	 ast::Expr::Lambda{ args: p,
	 		    body: Box::new(e),
			    typ:  ast::Typ::Ident(t.to_string()) },
    <e: Expr3> => e
    
}

// Binops with andalso orelse
Expr3: ast::Expr = {
    <l: Expr3> <o: "infix3"> <r:Expr4> => utils::make_binop(l, o,  r),
    <e: Expr4> => e
}

// Binops with < > <= >= = <>
Expr4: ast::Expr = {
    <l: Expr4> <o: "infix4"> <r:Expr6> => utils::make_binop(l, o, r),
    <l: Expr4> "=" <r:Expr6> => utils::make_binop(l, "=", r),
    <e: Expr6> => e
}

// Binops with + -
Expr6: ast::Expr = {
    <l: Expr6> <o: "infix6"> <r:Expr7> => utils::make_binop(l, o, r),
    <e: Expr7> => e
}

Expr7: ast::Expr = {
    <l: Expr7> "*" <r:Expr8> => utils::make_binop(l, "*", r),
    <e: Expr8> => e
}

Expr8: ast::Expr = {
    <e: ExprApp> => e
}

////////////////////////////////////

///////////// Helpers //////////////

// Two or more T separated by commas
CommaSepMulti<T>: Vec<T> = {
    <l: CommaSepMulti<T>> "," <r: T> => { let mut l = l; l.push(r); l },
    <l: T> "," <r: T> => vec![l, r]
}

Pattern: Vec<ast::Annot> = {
    <some: CommaSepMulti<Annot>> => some,
    "(" <v: "ident"> ":" <t: "ident"> ")" =>
        vec![ast::Annot{ var: v.to_string(),
			 typ: ast::Typ::Ident(t.to_string()) }],
    "(" ")" => vec![]
}
////////////////////////////////////

// Type annotated identifier.
Annot: ast::Annot = {
    <v1: "ident"> ":" <v2: "ident"> =>
    	 ast::Annot{ var: v1.to_string(),
	 	     typ: ast::Typ::Ident(v2.to_string()) }
}

ExprIf: ast::Expr = {
    "if" <e1: Expr> "then" <e2: Expr> "else" <e3: Expr> =>
    	 ast::Expr::Branch{ cond: Box::new(e1),
	 		    br_t: Box::new(e2),
			    br_f: Box::new(e3),
			    typ:  ast::Typ::Unknown }
}

//Function application, precedence 8
ExprApp: ast::Expr = {
    <e1: ExprApp> <e2: ExprAtom> =>
        ast::Expr::App{ fun: Box::new(e1),
			arg: Box::new(e2),
			typ: ast::Typ::Unknown },
    <e: ExprAtom> => e
}

// Atomic expressions have no ambiguities. Highest precedence
ExprAtom: ast::Expr = {
    // Constant unit
    "(" ")" =>
        ast::Expr::Con{ constnt: ast::Constant::Unit,
    	     		typ: ast::Typ::Unknown },
    "intLit" =>
    	ast::Expr::Con{ constnt: ast::Constant::Integer(<>),
    	     		typ: ast::Typ::Unknown },
    "boolLit" =>
    	ast::Expr::Con{ constnt: ast::Constant::Boolean(<>),
    	     		typ: ast::Typ::Unknown },
    "ident" =>
        ast::Expr::Var{ id: <>.to_string(),
	                typ: ast::Typ::Unknown },
    "(" <es: CommaSepMulti<Expr>> ")" =>
    	ast::Expr::Tuple{ coords: es,
			  typ: ast::Typ::Unknown },
    "(" <e: Expr> ")" => e,
}
